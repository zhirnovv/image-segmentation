#include "opencv2/core.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgcodecs.hpp"
#include <bits/stdc++.h>
#include <chrono>
#include <cmath>
#include <experimental/filesystem>
#include <fstream>

using namespace std;

const long long INF = 1e18;
const int OBJECT_MARKER = 2;
const int BACKGROUND_MARKER = 1;
const long double NOISE_RATIO = 5;

struct Edge {
  int v, u;
  long double edgeCapacity, reverseFlow, flow = 0;
  Edge(int v, int u, long double cap) : v(v), u(u), edgeCapacity(cap) {
    reverseFlow = 0;
  }
};

struct GraphProcessor {
  vector<Edge> edges;
  vector<Edge> residualNetwork;
  vector<vector<int>> adjacencyList;
  int n, m = 0;
  int source, sink;
  vector<int> level, ptr;
  queue<int> bfsQueue;
  queue<int> minCutQueue;

  GraphProcessor() {}

  GraphProcessor(int n, int s, int t) : n(n), source(s), sink(t) {
    adjacencyList.resize(n);
    level.resize(n);
    ptr.resize(n);
  }

  void addEdge(int v, int u, long double cap) {
    residualNetwork.emplace_back(v, u, cap);
    residualNetwork.emplace_back(u, v, 0);
    edges.emplace_back(v, u, cap);
    edges.emplace_back(u, v, 0);
    adjacencyList[v].push_back(m);
    adjacencyList[u].push_back(m + 1);
    m += 2;
  }

  bool bfs() {
    while (!bfsQueue.empty()) {
      int v = bfsQueue.front();
      bfsQueue.pop();
      for (int id : adjacencyList[v]) {
        if (edges[id].edgeCapacity - edges[id].flow <= 0)
          continue;
        if (level[edges[id].u] != -1)
          continue;
        level[edges[id].u] = level[v] + 1;
        bfsQueue.push(edges[id].u);
      }
    }
    return level[sink] != -1;
  }

  long double dfs(int v, long double pushed) {
    if (pushed == 0)
      return 0;

    if (v == sink)
      return pushed;

    for (int &cid = ptr[v]; cid < (int)adjacencyList[v].size(); cid++) {
      int id = adjacencyList[v][cid];
      int u = edges[id].u;
      if (level[v] + 1 != level[u] ||
          edges[id].edgeCapacity - edges[id].flow <= 0)
        continue;
      long double pushedFlow =
          dfs(u, min(pushed, edges[id].edgeCapacity - edges[id].flow));
      if (pushedFlow == 0)
        continue;
      edges[id].flow += pushedFlow;
      edges[id ^ 1].flow -= pushedFlow;
      return pushedFlow;
    }

    return 0;
  }

  long double flow() {
    cout << "Calculating max flow..." << endl;

    long double maxFlow = 0;

    while (true) {
      fill(level.begin(), level.end(), -1);
      level[source] = 0;
      bfsQueue.push(source);
      if (!bfs())
        break;
      fill(ptr.begin(), ptr.end(), 0);

      long double pushed = dfs(source, INF);

      while (pushed) {
        cout << maxFlow << ' ' << pushed << endl;
        maxFlow += pushed;
        pushed = dfs(source, INF);
      }
    }

    return maxFlow;
  }

  void buildResidualNetwork() {
    for (int i = 0; i < residualNetwork.size(); i++) {
      if (edges[i].flow >= 0) {
        residualNetwork[i].flow =
            residualNetwork[i].edgeCapacity + edges[i ^ 1].flow;
      } else {
        residualNetwork[i].flow = abs(edges[i].flow);
      }
    }
  }

  vector<long double> minCutBfs(vector<Edge> viableEdges) {
    vector<bool> isVisited;
    isVisited.resize(n, false);

    isVisited[source] = true;

    vector<long double> minCut;

    while (!minCutQueue.empty()) {
      int v = minCutQueue.front();
      minCutQueue.pop();

      minCut.push_back(v);

      vector<Edge> adjacentEdges;

      int to;
      long double flow;

      for (int id : adjacencyList[v]) {
        to = residualNetwork[id].u;
        flow = residualNetwork[id].flow;

        if (flow <= 0) {
          continue;
        }

        if (isVisited[to]) {
          continue;
        }

        isVisited[to] = true;
        minCutQueue.push(to);
      }
    }

    cout << "Done!" << endl;

    return minCut;
  }

  vector<long double> minCut() {
    buildResidualNetwork();

    vector<Edge> viableEdges;

    copy_if(residualNetwork.begin(), residualNetwork.end(),
            back_inserter(viableEdges),
            [](Edge potentialEdge) { return potentialEdge.flow > 0; });

    minCutQueue.push(source);

    return minCutBfs(viableEdges);
  }
};

struct ImageMask {
  cv::Mat image;
  vector<vector<int>> maskMatrix;

  ImageMask(cv::Mat image) : image(image) {
    maskMatrix.resize(image.rows, vector<int>(image.cols));
  };

  void addObjectMarker(int x, int y) { 
    maskMatrix[x][y] = OBJECT_MARKER; 
  }

  void addBackgroundMarker(int x, int y) {
    maskMatrix[x][y] = BACKGROUND_MARKER;
  }

  void buildMask() {
    cv::imshow("Marker Selector", image);
  }
};

struct ImageProcessor {
  string imagePath;
  cv::Mat image;
  GraphProcessor graph;
  ImageMask imageMask;

  long double getPixelEdgeCapacity(cv::Point start, cv::Point end) {
    double distance = cv::norm(cv::Mat(start), cv::Mat(end));
    cv::Scalar startIntensity = image.at<uchar>(start);
    cv::Scalar endIntensity = image.at<uchar>(end);

    return exp(-1 * pow(startIntensity.val[0] - endIntensity.val[0], 2) /
               (2 * pow(NOISE_RATIO, 2))) /
           distance;
  }

  int getPixelIndex(int x, int y) { return (y)*image.cols + x; }

  cv::Point getPixelPosition(int index) {
    return cv::Point(index % image.cols, index / image.cols);
  }

  ImageProcessor(string imagePath) : imagePath(imagePath) {
    image = cv::imread(imagePath, cv::IMREAD_GRAYSCALE);

    if (image.empty()) {
      throw runtime_error(
          "Could not load image. Please check if the image path is correct.");
    }

    imageMask = ImageMask(image.rows, image.cols);

    int imageSize = image.rows * image.cols + 2;
    graph = GraphProcessor(imageSize, imageSize - 2, imageSize - 1);

    /* cv::imshow("Seed input", image); */
    /* int key = cv::waitKey(0); */

    for (int i = 0; i < imageMask.rows; i++) {
      for (int j = 0; j < imageMask.cols; j++) {
        int maskIndex = getPixelIndex(i, j);
        switch (imageMask.maskMatrix[i][j]) {
        case (OBJECT_MARKER):
          graph.addEdge(imageSize - 2, maskIndex, INF);
          break;
        case (BACKGROUND_MARKER):
          graph.addEdge(maskIndex, imageSize - 1, INF);
        default:
          break;
        }
      }
    }

    cv::MatIterator_<uchar> it, end;
    cv::Point pixelPosition, rightPixelPosition, leftPixelPosition,
        topPixelPosition, bottomPixelPosition;
    int pixelIndex, rightPixelIndex, leftPixelIndex, topPixelIndex,
        bottomPixelIndex;

    for (it = image.begin<uchar>(), end = image.end<uchar>(); it < end; ++it) {
      pixelPosition = it.pos();
      rightPixelPosition = cv::Point(pixelPosition.x + 1, pixelPosition.y);
      leftPixelPosition = cv::Point(pixelPosition.x - 1, pixelPosition.y);
      topPixelPosition = cv::Point(pixelPosition.x, pixelPosition.y - 1);
      bottomPixelPosition = cv::Point(pixelPosition.x, pixelPosition.y + 1);

      pixelIndex = getPixelIndex(pixelPosition.x, pixelPosition.y);
      rightPixelIndex =
          getPixelIndex(rightPixelPosition.x, rightPixelPosition.y);
      leftPixelIndex = getPixelIndex(leftPixelPosition.x, leftPixelPosition.y);
      topPixelIndex = getPixelIndex(topPixelPosition.x, topPixelPosition.y);
      bottomPixelIndex =
          getPixelIndex(bottomPixelPosition.x, bottomPixelPosition.y);

      if (topPixelPosition.y >= 0) {
        graph.addEdge(pixelIndex, topPixelIndex,
                      getPixelEdgeCapacity(pixelPosition, topPixelPosition));
      }

      if (bottomPixelPosition.y <= image.rows - 1) {
        graph.addEdge(pixelIndex, bottomPixelIndex,
                      getPixelEdgeCapacity(pixelPosition, bottomPixelPosition));
      }

      if (leftPixelPosition.x >= 0) {
        graph.addEdge(pixelIndex, leftPixelIndex,
                      getPixelEdgeCapacity(pixelPosition, leftPixelPosition));
      }

      if (rightPixelPosition.x <= image.cols - 1) {
        graph.addEdge(pixelIndex, rightPixelIndex,
                      getPixelEdgeCapacity(pixelPosition, rightPixelPosition));
      }
    }

    cout << graph.flow() << endl;

    vector<long double> cut = graph.minCut();

    cv::Mat cutImage(image.rows, image.cols, cv::IMREAD_GRAYSCALE,
                     cv::Scalar());
    cv::Point cutPixelPosition;
    cv::Scalar intensity;

    // ignore source
    for (int i = 1; i < cut.size(); i++) {
      cutPixelPosition = getPixelPosition(cut[i]);
      cutImage.at<uchar>(cutPixelPosition) = 255;
    }

    imshow("Cut image", cutImage);
    cv::waitKey(0); // wait infinite time for a keypress
  }

  void buildMask() {}

  void performMinCut() {}
};

int main() {
  // test 2
  /* ImageMask mask = ImageMask(7, 7); */
  /* mask.addBackgroundMarker(0, 0); */
  /* mask.addObjectMarker(3, 4); */

  // test 3
  /* ImageMask mask = ImageMask(33, 29); */
  /* mask.addBackgroundMarker(0, 0); */
  /* mask.addObjectMarker(21, 22); */
  /* mask.addObjectMarker(22, 13); */

  // test 5, test 6
  ImageMask mask = ImageMask(640, 480);
  mask.addObjectMarker(121, 291);
  mask.addObjectMarker(411, 356);
  mask.addObjectMarker(538, 184);
  mask.addObjectMarker(48, 233);
  mask.addObjectMarker(498, 344);
  mask.addObjectMarker(197, 397);
  mask.addObjectMarker(394, 350);
  mask.addObjectMarker(522, 86);
  mask.addBackgroundMarker(0, 0);
  mask.addBackgroundMarker(226, 122);
  mask.addBackgroundMarker(543, 417);

  ImageProcessor processor("./tests/images/test_5.jpg", mask);

  return 0;

  /* string path = "./tests/dinic"; */

  /* int vertices, edges; */
  /* int start, end; */
  /* long double capacity; */
  /* chrono::time_point<chrono::system_clock> startTime, endTime; */

  /* for (const auto &entry : filesystem::directory_iterator(path)) { */
  /*   if (entry.path() != "./tests/dinic/test_kek2.txt") { */
  /*     continue; */
  /*   } */

  /*   cout << entry.path() << endl; */

  /*   ifstream infile(entry.path()); */

  /*   string line; */
  /*   getline(infile, line); */

  /*   istringstream graphParams(line); */
  /*   if (!(graphParams >> vertices >> edges)) { */
  /*     break; */
  /*   } */

  /*   GraphProcessor graph(vertices, 0, vertices - 1); */

  /*   for (int i = 0; i < edges; i++) { */
  /*     getline(infile, line); */

  /*     istringstream edgeParams(line); */
  /*     if (!(edgeParams >> start >> end >> capacity)) { */
  /*       break; */
  /*     } */
  /*     graph.addEdge(start - 1, end - 1, capacity); */
  /*   } */

  /*   startTime = chrono::system_clock::now(); */

  /*   cout << "Max flow is: " << graph.flow() << endl; */

  /*   vector<int> cut = graph.minCut(); */

  /*   for (int i = 0; i < cut.size(); i++) { */
  /*     cout << cut[i] + 1 << ' '; */
  /*   } */

  /*   cout << endl; */

  /*   endTime = chrono::system_clock::now(); */

  /*   cout << "Elapsed time: " */
  /*        << chrono::duration_cast<chrono::microseconds>(endTime - startTime)
   */
  /*               .count() */
  /*        << endl */
  /*        << endl; */
  /* } */

  /* return 0; */
}
